<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Saros - The Portal to Your Company Knowledge</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
  <style>
    /* Base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --bg-color: #050607;
      --text-color: #00ff9a;
      --shadow-color: #00ff9a33;
      --glow-color: #00ff9a55;
      --white-text: #ffffff;
    }
    
    body {
      font-family: "SF Pro Display", sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }
    
    .content {
      position: relative;
      z-index: 2;
      text-align: center;
      opacity: 0;
      transition: opacity 2s ease-in-out;
      width: 80vw;
      max-width: 600px;
    }
    
    h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 700;
      letter-spacing: 0.04em;
      line-height: 150%;
      margin-bottom: 1rem;
      font-size: 2.5rem;
      color: var(--text-color);
      text-shadow: 0 0 8px var(--glow-color), 0 0 16px var(--glow-color);
      animation: pulse 4s infinite;
    }
    
    @keyframes pulse {
      0% { text-shadow: 0 0 8px var(--glow-color), 0 0 16px var(--glow-color); }
      50% { text-shadow: 0 0 16px var(--glow-color), 0 0 24px var(--glow-color); }
      100% { text-shadow: 0 0 8px var(--glow-color), 0 0 16px var(--glow-color); }
    }
    
    h2 {
      font-family: 'VT323', monospace;
      font-weight: 400;
      letter-spacing: 0.04em;
      line-height: 120%;
      margin-bottom: 2rem;
      font-size: 2rem;
      color: var(--white-text);
      text-shadow: 0 0 5px var(--glow-color);
    }
    
    button {
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 700;
      letter-spacing: 0.04em;
      background-color: #000000;
      color: var(--text-color);
      border: 2px solid var(--text-color);
      border-radius: 26px;
      padding: 0 24px;
      height: 52px;
      cursor: pointer;
      transition: all 160ms ease-out;
      box-shadow: 0 0 12px var(--glow-color), 0 0 24px var(--glow-color);
      min-width: 180px;
      font-size: 1rem;
      position: relative;
      overflow: hidden;
    }
    
    button:before {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: linear-gradient(45deg, rgba(0,255,154,0.2), rgba(0,255,154,0));
      filter: blur(5px);
      opacity: 0;
      transition: opacity 300ms ease-out;
    }
    
    button:hover, button:focus {
      background-color: var(--text-color);
      color: #000000;
      outline: none;
      box-shadow: 0 0 15px var(--glow-color), 0 0 30px var(--glow-color);
    }
    
    button:hover:before {
      opacity: 1;
    }
    
    /* Glassmorphism for future login overlay */
    .glass-card {
      backdrop-filter: blur(30px) saturate(180%);
      background-color: rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 8px var(--shadow-color);
      padding: 2rem;
    }
    
    @media (prefers-reduced-motion: reduce) {
      .content {
        transition: opacity 2s ease-in-out;
      }
      
      button {
        transition: none;
      }
      
      h1 {
        animation: none;
        text-shadow: 0 0 12px var(--glow-color);
      }
    }
    
    @media (max-width: 768px) {
      h1 {
        font-size: 1.8rem;
      }
      
      h2 {
        font-size: 1.5rem;
      }
      
      button {
        min-height: 48px; /* Ensure min-tap area of 48px */
      }
    }
  </style>
</head>
<body>
  <canvas id="grid-canvas"></canvas>
  <div class="content">
    <h1>Saros</h1>
    <h2>The portal to your company knowledge</h2>
    <button id="enter-portal">Enter Portal</button>
  </div>
  
  <script>
    (function() {
      // Canvas setup
      const canvas = document.getElementById('grid-canvas');
      const ctx = canvas.getContext('2d');
      const content = document.querySelector('.content');
      const enterPortalBtn = document.getElementById('enter-portal');
      
      // Configuration
      const config = {
        gridSpacing: 5, // Increased spacing to reduce visual complexity
        glyphSize: 6,
        waveAmplitude: 20, // Reduced from 40
        waveFrequency: 0.03, // Slower frequency to reduce headache effect
        promptFlickerInterval: 1200, // Increased from 600ms to reduce flickering
        plusColor: '#00ff9a',
        backgroundColor: '#050607',
        promptColor: '#ffffff',
        reduceMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
        globalWaveFrequency: 0.2, // Reduced from 0.4
        globalWaveAmplitude: 2, // Reduced from 5
        // Full screen ripple effect
        rippleFrequency: 0.05, // Reduced from 0.1
        rippleAmplitude: 8, // Reduced from 15
        rippleDensity: 180, // Reduced density for cleaner look
        screenColor: '#00ff9a', // Bright green for the full screen effect
        textLines: 12, // Reduced from 20
        textSpeed: 0.3, // Reduced from 0.5
        screenGlowIntensity: 0.6 // Reduced from 0.8
      };
      
      // Timing and animation state
      let startTime = null;
      let lastTime = 0;
      let promptFlickerTime = 0;
      let offscreenCanvas = null;
      let offscreenCtx = null;
      let rows = [];
      let flowingTextLines = [];
      
      // Sample AI prompts
      const aiPrompts = [
        'analyze market trends',
        'summarize project status',
        'generate quarterly report',
        'extract key insights',
        'provide competitive analysis',
        'forecast revenue growth',
        'identify customer patterns',
        'create strategic roadmap',
        'optimize resource allocation',
        'evaluate team performance'
      ];
      
      // Initialize
      function init() {
        setupCanvas();
        createEnhancedBackground();
        setupFlowingTextLines();
        setupEventListeners();
        startAnimation();
        
        // Show content after longer delay
        setTimeout(() => {
          content.style.opacity = '1';
        }, 2000); // Changed to 2000ms (2s) as requested
      }
      
      // Set up the canvas
      function setupCanvas() {
        // Set canvas size to match window with device pixel ratio for sharpness
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        ctx.scale(dpr, dpr);
        
        // We no longer need the offscreen canvas since we're drawing directly
        // But we'll keep the structure in case we need it later
        offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = canvas.width;
        offscreenCanvas.height = canvas.height;
        offscreenCtx = offscreenCanvas.getContext('2d');
        offscreenCtx.scale(dpr, dpr);
      }
      
      // Create the enhanced background with grid and prompts
      function createEnhancedBackground() {
        rows = [];
        const numRows = Math.ceil(window.innerHeight / config.gridSpacing) + 1;
        const numCols = Math.ceil(window.innerWidth / config.gridSpacing) + 1;
        
        for (let i = 0; i < numRows; i++) {
          const rowY = i * config.gridSpacing;
          const hasPrompt = Math.random() < 0.1; // Reduced from 0.15 to have fewer prompts
          const promptText = hasPrompt ? aiPrompts[Math.floor(Math.random() * aiPrompts.length)] : '';
          const promptCol = hasPrompt ? Math.floor(Math.random() * (numCols - promptText.length - 5)) + 5 : -1;
          
          rows.push({
            y: rowY,
            offset: 0,
            phase: Math.random() * Math.PI * 2, // Random starting phase
            speed: 0.3 + Math.random() * 0.3, // Reduced speed range for gentler animation
            hasPrompt,
            promptText,
            promptCol,
            promptOpacity: 0.4 + Math.random() * 0.4 // Reduced max opacity
          });
        }
      }
      
      // Pre-render the grid to offscreen canvas for efficiency
      function preRenderGrid() {
        offscreenCtx.fillStyle = config.backgroundColor;
        offscreenCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        
        // Apply a bright green background tint
        offscreenCtx.fillStyle = 'rgba(0, 255, 154, 0.03)'; // Reduced opacity
        offscreenCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        
        offscreenCtx.font = `${config.glyphSize}px "SF Mono", Menlo, monospace`;
        offscreenCtx.fillStyle = config.plusColor;
        
        // Draw a cleaner grid for a more electronic look
        const gridSpacing = Math.max(2, Math.min(window.innerWidth, window.innerHeight) / config.rippleDensity);
        
        for (let y = 0; y < window.innerHeight; y += gridSpacing) {
          for (let x = 0; x < window.innerWidth; x += gridSpacing) {
            // Use '.' instead of '+' for a more electronic/digital look
            offscreenCtx.fillText('.', x, y);
          }
        }
      }
      
      // Setup flowing text lines for the CRT screen effect
      function setupFlowingTextLines() {
        flowingTextLines = [];
        
        // Sample text snippets that will flow across the screen
        const textSnippets = [
          "analyzing data...",
          "knowledge base connected",
          "processing information",
          "searching archives",
          "system online",
          "data transfer complete",
          "acquiring knowledge",
          "neural link established",
          "syncing databases",
          "company insights ready",
          "access granted",
          "knowledge assets indexed",
          "portal ready",
          "ai assistant activated",
          "initializing systems"
        ];
        
        // Create flowing text lines
        for (let i = 0; i < config.textLines; i++) {
          const y = Math.random() * window.innerHeight;
          const text = textSnippets[Math.floor(Math.random() * textSnippets.length)];
          const speed = (0.3 + Math.random() * 0.7) * config.textSpeed; // More varied but overall slower speeds
          
          flowingTextLines.push({
            text,
            x: -200 - Math.random() * 500, // Start off-screen to the left
            y,
            speed,
            opacity: 0.2 + Math.random() * 0.3 // Lower opacity range
          });
        }
      }
      
      // Handle window resize
      function handleResize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        ctx.scale(dpr, dpr);
        
        // Recreate background
        createEnhancedBackground();
        
        // Re-setup flowing text lines
        setupFlowingTextLines();
      }
      
      // Set up event listeners
      function setupEventListeners() {
        window.addEventListener('resize', handleResize);
        
        enterPortalBtn.addEventListener('click', function(e) {
          e.preventDefault();
          window.location.href = '/app'; // Navigate to app directly, not in new tab
        });
      }
      
      // Start the animation
      function startAnimation() {
        startTime = performance.now();
        lastTime = startTime;
        
        if (config.reduceMotion) {
          // Draw static scene for reduced motion preference
          drawStaticScene();
        } else {
          requestAnimationFrame(animate);
        }
      }
      
      // Draw static scene for reduced motion
      function drawStaticScene() {
        // Apply background
        ctx.fillStyle = config.backgroundColor;
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        
        // Apply CRT screen filter effect
        ctx.fillStyle = config.screenColor;
        ctx.globalAlpha = 0.05; // Reduced from 0.1
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        ctx.globalAlpha = 1.0;
        
        // Draw static grid directly - using dots instead of plus signs for electronic look
        ctx.font = `${config.glyphSize}px "SF Mono", Menlo, monospace`;
        ctx.fillStyle = config.plusColor;
        
        const gridSpacing = Math.max(2, Math.min(window.innerWidth, window.innerHeight) / config.rippleDensity);
        
        for (let y = 0; y < window.innerHeight; y += gridSpacing) {
          for (let x = 0; x < window.innerWidth; x += gridSpacing) {
            // Add some variation to the grid
            if (Math.random() > 0.5) {
              ctx.fillText('.', x, y); // Use dot for more electronic look
            }
          }
        }
        
        // Draw static prompts
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        
        for (let row of rows) {
          if (row.hasPrompt) {
            const promptX = row.promptCol * config.gridSpacing;
            ctx.fillText(row.promptText, promptX, row.y);
          }
        }
        
        // Draw some static flowing text
        ctx.fillStyle = `rgba(0, 255, 154, 0.5)`;
        
        for (let line of flowingTextLines) {
          const x = Math.random() * window.innerWidth;
          ctx.fillText(line.text, x, line.y);
        }
        
        // Add static glow effect
        addScreenGlow();
      }
      
      // Animation loop
      function animate(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        
        // Update prompt flicker timing
        promptFlickerTime += deltaTime;
        if (promptFlickerTime > config.promptFlickerInterval) {
          promptFlickerTime = 0;
          // Update prompt opacities
          for (let row of rows) {
            if (row.hasPrompt) {
              row.promptOpacity = 0.4 + Math.random() * 0.4; // Reduced max opacity
            }
          }
        }
        
        // Clear the canvas with background
        ctx.fillStyle = config.backgroundColor;
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        
        // Apply CRT screen filter effect
        ctx.fillStyle = config.screenColor;
        ctx.globalAlpha = 0.05; // Reduced from 0.1
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        ctx.globalAlpha = 1.0;
        
        // Apply global wave motion - much subtler
        ctx.save();
        ctx.translate(0, Math.sin(elapsed * 0.0005 * config.globalWaveFrequency) * config.globalWaveAmplitude);
        
        // Draw ripple grid - the main green grid pattern without using offscreenCanvas
        drawRippleGrid(timestamp);
        
        // Draw flowing text lines
        drawFlowingText(elapsed, deltaTime);
        
        ctx.restore();
        
        // Add screen glow effect
        addScreenGlow();
        
        // Continue animation loop
        requestAnimationFrame(animate);
      }
      
      // Add a CRT screen glow effect
      function addScreenGlow() {
        // Create a radial gradient for the glow
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const radius = Math.max(window.innerWidth, window.innerHeight) * 0.8;
        
        const gradient = ctx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, radius
        );
        
        gradient.addColorStop(0, `rgba(0, 255, 154, ${0.08 * config.screenGlowIntensity})`);
        gradient.addColorStop(0.5, `rgba(0, 255, 154, ${0.04 * config.screenGlowIntensity})`);
        gradient.addColorStop(1, 'rgba(0, 255, 154, 0)');
        
        // Apply the glow
        ctx.fillStyle = gradient;
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        ctx.globalCompositeOperation = 'source-over';
      }
      
      // Draw the grid with ripple effect
      function drawRippleGrid(timestamp) {
        // Apply a slight green tint to the background
        ctx.fillStyle = 'rgba(0, 255, 154, 0.02)'; // Reduced opacity
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        
        // Apply a ripple effect over the entire grid
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        // Draw distorted grid points directly to the main canvas
        const time = timestamp * 0.0007; // Slowed down significantly
        
        // Draw digital dots instead of plus signs for a more electronic look
        ctx.font = `${config.glyphSize}px "SF Mono", Menlo, monospace`;
        ctx.fillStyle = config.plusColor;
        
        const gridSpacing = Math.max(4, Math.min(window.innerWidth, window.innerHeight) / config.rippleDensity);
        
        for (let y = 0; y < window.innerHeight; y += gridSpacing) {
          for (let x = 0; x < window.innerWidth; x += gridSpacing) {
            // Calculate distance from center
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate ripple effect with gentler motion
            const angle = Math.atan2(dy, dx);
            const rippleFactor = Math.sin(distance * config.rippleFrequency - time) * config.rippleAmplitude;
            
            // Apply ripple displacement
            const displaceX = rippleFactor * Math.cos(angle);
            const displaceY = rippleFactor * Math.sin(angle);
            
            // Use a digital dot instead of plus sign
            if (Math.random() > 0.4) { // Show more dots for a denser but still clean grid
              ctx.fillText('.', x + displaceX, y + displaceY);
            }
          }
        }
        
        // Draw AI prompts that appear to float in the grid
        ctx.font = `${config.glyphSize}px "SF Mono", Menlo, monospace`;
        
        for (let row of rows) {
          if (row.hasPrompt) {
            ctx.fillStyle = `rgba(255, 255, 255, ${row.promptOpacity})`;
            const promptX = row.promptCol * config.gridSpacing + 
                            Math.sin(time * row.speed * 0.3) * 10; // Gentler horizontal motion
            ctx.fillText(row.promptText, promptX, row.y);
          }
        }
      }
      
      // Draw flowing text across the screen
      function drawFlowingText(elapsed, deltaTime) {
        ctx.font = `${config.glyphSize}px "SF Mono", Menlo, monospace`;
        
        // Update and draw each text line
        for (let i = 0; i < flowingTextLines.length; i++) {
          const line = flowingTextLines[i];
          
          // Update position - slower movement
          line.x += line.speed * deltaTime * 0.05; // Reduced from 0.1
          
          // If text has moved off screen, reset to start with new text
          if (line.x > window.innerWidth + 100) {
            line.x = -200 - Math.random() * 300;
            line.y = Math.random() * window.innerHeight;
            line.opacity = 0.2 + Math.random() * 0.3; // Lower opacity range
          }
          
          // Set text style with fading opacity near the edges
          const distFromCenter = Math.abs((line.x / window.innerWidth) - 0.5) * 2; // 0 at center, 1 at edges
          const edgeFade = Math.max(0, 1 - Math.pow(distFromCenter, 1.5));
          
          ctx.fillStyle = `rgba(0, 255, 154, ${line.opacity * edgeFade})`;
          ctx.fillText(line.text, line.x, line.y);
        }
      }
      
      // Initialize on load
      window.addEventListener('DOMContentLoaded', init);
    })();
  </script>
</body>
</html>
